import {getDefaultJsonSimplifierOptions, JsonSimplifierOptions, simplifyJson, simplifyValue} from './JsonSimplifier';
import {LogLevel, LogPipe} from './ConsoleOverrides';

/** Options for JsonPipe. */
export interface JsonPipeOptions extends JsonSimplifierOptions {
    /**
     * Top-level property name that includes a concatenated message of all strings and primitive types passed to console.log.
     * Default: 'message'.
     */
    messagePropertyName: string;

    /**
     * Log level property name.
     * If <null>, no log level info is added to the result JSON.
     * Default: 'level'.
     */
    levelPropertyName: string | null;

    /** Log level value formatter. User only if @levelPropertyName is not <null>. */
    levelPropertyFormatter: (level: LogLevel) => string;

    /**
     * Timestamp property name.
     * If <null>, no timestamp is added to the result JSON.
     * Default: 'timestamp'.
     */
    timestampPropertyName: string | null;

    /** Timestamp formatter. User only if @timestampPropertyName is not <null>. */
    timestampPropertyFormatter: (timeInMillis: number) => string;

    /**
     * Message id property name.
     * If <null>, no message id is added to the result JSON.
     * Default: 'message_id'.
     */
    messageIdPropertyName: string | null;

    /**
     * Message id property value provider.
     * Default: a uuid like value generated by *generateUuidSimple*.
     * When *undefined* is returned falls back to *generateUuidSimple* result.
     */
    messageIdPropertyProvider: (level: LogLevel, ...args: Array<unknown>) => string | undefined;

    /**
     *  Builds object token for the message.
     *  By default, uses '$N' as a pattern where 'N' is positional a number (@messageArgumentIndex + 1)
     *  of the console.log argument not inlined into the message.
     *  @originalArgumentIndex is the original index of the argument in console.log() call.
     *  Example:
     *      console.log('a', {f:0}, 'b', {f:0});
     *      @messageArgumentIndex = 0, 1.
     *      @originalArgumentIndex = 1, 3.
     */
    getObjectMessageToken: (messageArgumentIndex: number, argument: object, originalArgumentIndex: number) => string;

    /**
     * For a single top-level field objects uses field name as an argument name and includes only a field sub-objects into arguments.
     *
     * Example: console("Hello", {headers: {header1:'', header2: ''}});
     *
     * pickFieldNameAsObjectMessageTokenForSingleFieldObjects = true:
     *  {"message":"Hello $headers","$headers":{"header1":"","header2":""}}
     *
     * pickFieldNameAsObjectMessageTokenForSingleFieldObjects = false:
     *  {"message":"Hello $1","$1":{"headers":{"header1":"","header2":""}}}
     *
     * Default: false. Overrides 'getObjectMessageToken'.
     */
    pickFieldNameAsObjectMessageTokenForSingleFieldObjects: boolean;

    /**
     * Used to provide a default value to reveal present but undefined fields.
     * The default value is <undefined> which results the fields with undefined value be excluded from the log.
     */
    undefinedMessageValue: undefined | string;
}

/** Returns default properties used by 'createJsonPipe'. */
export function getDefaultJsonPipeOptions()
    : JsonPipeOptions & {
    levelPropertyName: string,
    timestampPropertyName: string,
    messageIdPropertyName: string,
    messageIdPropertyProvider: () => string,
} {
    return {
        ...getDefaultJsonSimplifierOptions(),

        messagePropertyName: 'message',

        levelPropertyName: 'level',
        levelPropertyFormatter: level => level,

        timestampPropertyName: 'timestamp',
        timestampPropertyFormatter: timeInMillis => new Date(timeInMillis).toISOString(),

        messageIdPropertyName: 'message_id',
        messageIdPropertyProvider: generateUuidSimple,

        isIgnoredProperty: () => false,
        getObjectMessageToken: argumentIndex => `$${argumentIndex + 1}`,
        pickFieldNameAsObjectMessageTokenForSingleFieldObjects: false,
        undefinedMessageValue: undefined,
    };
}

export interface JsonPipe extends LogPipe<unknown[]> {
    /**
     * Returns the last message ID assigned by the pipe.
     * If no messages were emitted yet contains an empty string.
     * If 'messageIdPropertyName' is null on the JsonPipe configuration (no ID is assigned), the value stays empty.
     */
    getLastMessageId: () => string;
    /**
     * Sets next emitted message id.
     * When set the *messageIdPropertyProvider* won't be used to generate the next message id.
     */
    setNextMessageId: (messageId: string) => void;
}

/**
 * Creates a pipe that converts console arguments into a serializable JSON object.
 */
export function createJsonPipe(inputOptions: Partial<JsonPipeOptions> = {}): JsonPipe {
    const defaultJsonPipeOptions = getDefaultJsonPipeOptions();
    const options: JsonPipeOptions = {...defaultJsonPipeOptions, ...inputOptions};
    let lastMessageId = '';
    let nextMessageId: string | undefined;
    const logPipe: LogPipe = (level, ...args) => {
        const resultJson: Record<string, unknown> = {};
        let message: string | undefined = undefined;
        resultJson[options.messagePropertyName] = undefined; // Set it first, so it will be the first property in JSON.
        let messageArgIndex = 0;
        for (let argIndex = 0; argIndex < args.length; argIndex++) {
            const arg = simplifyValue(args[argIndex]);
            let messageToken = arg;
            if (typeof arg === 'object' && arg !== null) {
                let childValue = simplifyJson(arg, options);
                if (options.pickFieldNameAsObjectMessageTokenForSingleFieldObjects
                    && typeof childValue === 'object'
                    && childValue !== null
                ) {
                    const childValueEntries = Object.entries(childValue);
                    if (childValueEntries.length === 1) {
                        const [childFieldName, childFieldValue] = childValueEntries[0];
                        const newMessageToken = `$${childFieldName}`;
                        if (resultJson[newMessageToken] === undefined) {
                            messageToken = newMessageToken;
                            if (isInlinedObjectMessageTokenValue(childFieldValue)) {
                                const quote = typeof childFieldValue === 'string' ? '\'' : '';
                                messageToken += `:[${quote}${childFieldValue}${quote}]`;
                                childValue = undefined;
                            } else {
                                childValue = childFieldValue;
                            }
                        }
                    }
                }
                if (typeof messageToken !== 'string') {
                    messageToken = options.getObjectMessageToken(messageArgIndex, arg, argIndex);
                    messageArgIndex++;
                }
                resultJson[messageToken] = childValue;
            } else if (arg === undefined) {
                if (options.undefinedMessageValue !== undefined) {
                    messageToken += options.undefinedMessageValue;
                }
            } else {
                messageToken = arg;
            }
            message = message === undefined ? `${messageToken}` : `${message} ${messageToken}`;
        }
        if (message) {
            resultJson[options.messagePropertyName] = message;
        }
        if (options.levelPropertyName) {
            resultJson[options.levelPropertyName] = options.levelPropertyFormatter(level);
        }
        if (options.timestampPropertyName) {
            resultJson[options.timestampPropertyName] = options.timestampPropertyFormatter(Date.now());
        }
        if (options.messageIdPropertyName) {
            let messageId = nextMessageId || options.messageIdPropertyProvider(level, ...args);
            if (messageId === undefined) {
                messageId = defaultJsonPipeOptions.messageIdPropertyProvider();
            }
            lastMessageId = messageId;
            resultJson[options.messageIdPropertyName] = lastMessageId;
            nextMessageId = undefined;
        }
        return [resultJson];
    };
    const jsonPipe: JsonPipe = logPipe as JsonPipe;
    jsonPipe.getLastMessageId = (): string => lastMessageId;
    jsonPipe.setNextMessageId = (messageId): void => {nextMessageId = messageId;};
    return jsonPipe;
}

/**
 *  Returns 'true' if the value can be inlined as a part of the
 * 'pickFieldNameAsObjectMessageTokenForSingleFieldObjects' transformation.
 */
function isInlinedObjectMessageTokenValue(value: unknown): boolean {
    return value === null ||
        typeof value === 'string' ||
        typeof value === 'undefined' ||
        typeof value === 'number' ||
        typeof value === 'boolean';
}

/**
 * Generates a random uuid-like string.
 * The method does not provide the same level of randomness like 'crypto' based UUID generators.
 * but it is good for most logging purposes were message id uniqueness is required only on some time-local period.
 */
export function generateUuidSimple(): string {
    let datePart = Date.now();
    // noinspection SpellCheckingInspection
    return 'xxxxxxxx-xxxx-4xxx-yxxx-xxxxxxxxxxxx'.replace(/[xy]/g, c => {
        const randomPart = (datePart + Math.floor(Math.random() * 16)) % 16;
        datePart = Math.floor(datePart / 16);
        return (c === 'x' ? randomPart : (randomPart & 0x3 | 0x8)).toString(16);
    });
}

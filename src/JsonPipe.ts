import {DEFAULT_JSON_SIMPLIFIER_OPTIONS, JsonSimplifierOptions, simplifyJson, simplifyValue} from './JsonSimplifier';
import {LogLevel, LogPipe} from './ConsoleOverrides';

/** Options for JsonPipe. */
export interface JsonPipeOptions extends JsonSimplifierOptions {
    /**
     * Top-level property name that includes a concatenated message of all strings and primitive types passed to console.log.
     * Default: 'message'.
     */
    messagePropertyName: string;

    /**
     * Log level property name.
     * If <null>, no log level info is added to the result JSON.
     * Default: 'level'.
     */
    levelPropertyName: string | null;

    /** Log level value formatter. User only if @levelPropertyName is not <null>. */
    levelPropertyFormatter: (level: LogLevel) => string;

    /**
     * Timestamp property name.
     * If <null>, no timestamp is added to the result JSON.
     * Default: '@timestamp'.
     */
    timestampPropertyName: string | null;

    /** Timestamp formatter. User only if @timestampPropertyName is not <null>. */
    timestampPropertyFormatter: (timeInMillis: number) => string;

    /**
     * Message id property name.
     * If <null>, no message id is added to the result JSON.
     * Default: '@messageId'.
     */
    idPropertyName: string | null;

    /**
     * Message id property value provider.
     * Default: a uuid like value generated by 'generateUuidSimple'.
     */
    idPropertyProvider: (level: LogLevel, ...args: Array<unknown>) => string;

    /**
     *  Builds object token for the message.
     *  By default, uses '$N' as a pattern where 'N' is positional a number (@messageArgumentIndex + 1)
     *  of the console.log argument not inlined into the message.
     *  @originalArgumentIndex is the original index of the argument in console.log() call.
     *  Example:
     *      console.log('a', {f:0}, 'b', {f:0});
     *      @messageArgumentIndex = 0, 1.
     *      @originalArgumentIndex = 1, 3.
     */
    getObjectMessageToken: (messageArgumentIndex: number, argument: object, originalArgumentIndex: number) => string;

    /**
     * For a single top-level field objects uses field name as an argument name and includes only a field sub-objects into arguments.
     *
     * Example: console("Hello", {headers: {header1:'', header2: ''}});
     *
     * pickFieldNameAsObjectMessageTokenForSingleFieldObjects = true:
     *  {"message":"Hello $headers","$headers":{"header1":"","header2":""}}
     *
     * pickFieldNameAsObjectMessageTokenForSingleFieldObjects = false:
     *  {"message":"Hello $1","$1":{"headers":{"header1":"","header2":""}}}
     *
     * Default: false. Overrides 'getObjectMessageToken'.
     */
    pickFieldNameAsObjectMessageTokenForSingleFieldObjects: boolean;

    /**
     * Used to provide a default value to reveal present but undefined fields.
     * The default value is <undefined> which results the fields with undefined value be excluded from the log.
     */
    undefinedMessageValue: undefined | string;

    /**
     * If an object parameter of console.log() contains a top-level property marked as isTopLevelProperty,
     * the property is moved from the object to the top-level JSON
     * (same level as 'message', '@timestamp', '@level' fields).
     */
    isTopLevelProperty: (propertyName: string) => boolean;
}

export const DEFAULT_JSON_PIPE_OPTIONS: Readonly<JsonPipeOptions & {
    levelPropertyName: string,
    timestampPropertyName: string,
    idPropertyName: string
}> = {
    ...DEFAULT_JSON_SIMPLIFIER_OPTIONS,
    messagePropertyName: 'message',

    levelPropertyName: 'level',
    levelPropertyFormatter: level => level,

    timestampPropertyName: '@timestamp',
    timestampPropertyFormatter: timeInMillis => new Date(timeInMillis).toISOString(),

    idPropertyName: '@messageId',
    idPropertyProvider: generateUuidSimple,

    isTopLevelProperty: propertyName => propertyName.startsWith('@'),
    isIgnoredProperty: () => false,
    getObjectMessageToken: argumentIndex => `$${argumentIndex + 1}`,
    pickFieldNameAsObjectMessageTokenForSingleFieldObjects: false,
    undefinedMessageValue: undefined,
};

/**
 * Creates a pipe that converts console arguments into a serializable JSON object.
 */
export function createJsonPipe(inputOptions: Partial<JsonPipeOptions> = {}): LogPipe {
    const options: JsonPipeOptions = {...DEFAULT_JSON_PIPE_OPTIONS, ...inputOptions};
    const topLevelPickerOptions: PickTopLevelPropertiesOptions = {
        isTopLevelProperty: options.isTopLevelProperty,
        ignoredPropertyNames: [options.messagePropertyName],
    };
    return (level, ...args) => {
        const resultJson: Record<string, unknown> = {};
        let message: string | undefined = undefined;
        resultJson[options.messagePropertyName] = undefined; // Set it first, so it will be the first property in JSON.
        let messageArgIndex = 0;
        for (let argIndex = 0; argIndex < args.length; argIndex++) {
            const arg = simplifyValue(args[argIndex]);
            let messageToken = arg;
            if (typeof arg === 'object' && arg !== null) {
                const topLevelProperties = pickTopLevelProperties(arg, topLevelPickerOptions);
                for (const [topLevelPropertyName, topLevelPropertyValue] of Object.entries(topLevelProperties)) {
                    resultJson[topLevelPropertyName] = topLevelPropertyValue;
                }
                // Add top-level properties to the list of ignored when calling convertToSafeJson.
                const simplifyOptions: JsonSimplifierOptions = {
                    ...options,
                    isIgnoredProperty: name => options.isIgnoredProperty(name) || name in topLevelProperties
                };
                let childValue = simplifyJson(arg, simplifyOptions);
                if (options.pickFieldNameAsObjectMessageTokenForSingleFieldObjects
                    && typeof childValue === 'object'
                    && childValue !== null
                    && Object.keys(childValue).length === 1) {
                    const [childFieldName, childFieldValue] = Object.entries(childValue)[0];
                    messageToken = `$${childFieldName}`;
                    if (isInlinedObjectMessageTokenValue(childFieldValue)) {
                        const quote = typeof childFieldValue === 'string' ? '\'' : '';
                        messageToken += `:[${quote}${childFieldValue}${quote}]`;
                        childValue = undefined;
                    } else {
                        childValue = childFieldValue;
                    }
                    // messageArgIndex is not increased to stay continuous.
                } else {
                    messageToken = options.getObjectMessageToken(messageArgIndex, arg, argIndex);
                    messageArgIndex++;
                }
                resultJson[messageToken] = childValue;
            } else if (arg === undefined) {
                if (options.undefinedMessageValue !== undefined) {
                    messageToken += options.undefinedMessageValue;
                }
            } else {
                messageToken = arg;
            }
            message = message === undefined ? `${messageToken}` : `${message} ${messageToken}`;
        }
        if (message) {
            resultJson[options.messagePropertyName] = message;
        }
        if (options.levelPropertyName) {
            resultJson[options.levelPropertyName] = options.levelPropertyFormatter(level);
        }
        if (options.timestampPropertyName) {
            resultJson[options.timestampPropertyName] = options.timestampPropertyFormatter(Date.now());
        }
        if (options.idPropertyName) {
            resultJson[options.idPropertyName] = options.idPropertyProvider(level, ...args);
        }
        return [resultJson];
    };
}

export interface PickTopLevelPropertiesOptions {
    isTopLevelProperty: (propertyName: string) => boolean;
    ignoredPropertyNames: string[];
}

export function pickTopLevelProperties(obj: object,
                                       inputOptions: Partial<PickTopLevelPropertiesOptions> = {}
): Record<string, unknown> {
    const options = {
        isTopLevelProperty: DEFAULT_JSON_PIPE_OPTIONS.isTopLevelProperty,
        ignoredPropertyNames: [],
        ...inputOptions,
    };
    const result: Record<string, unknown> = {};
    for (const [key, value] of Object.entries(obj)) {
        if (options.isTopLevelProperty(key) && !options.ignoredPropertyNames.includes(key)) {
            result[key] = value;
        }
    }
    return result;
}

/** Returns 'true' if the value can be inlined as a part of 'pickFieldNameAsObjectMessageTokenForSingleFieldObjects' transformation. */
function isInlinedObjectMessageTokenValue(value: unknown): boolean {
    return value === null ||
        typeof value === 'string' ||
        typeof value === 'undefined' ||
        typeof value === 'number' ||
        typeof value === 'boolean';
}

/**
 * Generates a random uuid-like string.
 * The method does not provide the same level of randomness like 'crypto' based UUID generators.
 * but it is good for most logging purposes were message id uniqueness is required only on some time-local period.
 */
export function generateUuidSimple(): string {
    let datePart = Date.now();
    return 'xxxxxxxx-xxxx-4xxx-yxxx-xxxxxxxxxxxx'.replace(/[xy]/g, c => {
        const randomPart = (datePart + Math.floor(Math.random() * 16)) % 16;
        datePart = Math.floor(datePart / 16);
        return (c == 'x' ? randomPart : (randomPart & 0x3 | 0x8)).toString(16);
    });
}
